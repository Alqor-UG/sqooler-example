{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the sqooler example","text":"<p>This is a collection of cold atom simulators that you can access through the <code>qiskit-cold-atom</code> and the <code>qlued</code> interface:</p> <ul> <li><code>qiskit-cold-atom</code> allows the enduser to write the circuit definitions on its laptop and send them to the server in form of a nice json file.</li> <li><code>qlued</code> handles the user management and stores the received json file in an appropiate queue.</li> <li><code>sqooler</code> acts as the backend that performs the calculations from the queue and sends back the result into the storage.</li> </ul> <p>To enable this work-flow, the simulator has to follow a few rules on how to parse the json files etc. This is what we have started to standardize and simplify as much as possible. In the following we documented each module its purpose and look forward to your contributions.</p>"},{"location":"#getting-started-on-heroku","title":"Getting started on heroku","text":"<p>The simplest way to use the package is to deploy it to <code>heroku</code>. This directly starts the <code>maintainer.py</code> in a loop, because it is defined like that in the <code>Procfile</code>.  However, you will also need to have the following credentials of the Dropbox:</p> <ul> <li><code>APP_KEY</code>, <code>APP_SECRET</code> and <code>REFRESH_TOKEN</code>. Please head over to the documentation of <code>qlued</code> to see how they might be set up.</li> <li>They should be all defined <code>Settings</code> &gt; <code>Config Vars</code>. </li> <li>Now your system  should automatically look for jobs that are under <code>Backend_files/Queued_Jobs</code>, process them and safe the result under <code>Backend_files/Finished_Jobs</code>.</li> </ul>"},{"location":"#getting-started-locally","title":"Getting started locally","text":"<p>!!! note</p> <pre><code>This part of the documentiation needs a lot of love. Feel free to help us making it more understandable.\n</code></pre> <p>If you would like to write some new simulator, extend it etc, you will need to deploy the code locally. Then you will need to:</p> <ul> <li>clone or fork the repo.</li> <li>pip install the <code>requirements.txt</code>.</li> <li>define <code>APP_KEY</code>, <code>APP_SECRET</code> and <code>REFRESH_TOKEN</code> in the <code>.env</code> file that is you should create in the root directory.</li> </ul>"},{"location":"#first-steps","title":"First steps","text":"<p>The whole system is set up on <code>python</code>. First, create a local environment. You can then install the requirements via <code>pip install -r requirements-dev.txt</code>.</p> <p>Second, we need to enable the storage of the settings, which we manage with python-decouple. To do so, create a <code>.env</code> file in the root directory. </p> <pre><code>project\n\u2502   README.md\n\u2502   maintainer.py\n|   .env\n|   ...    \n\u2502\n\u2514\u2500\u2500\u2500.github\n\u2502   \u2502   ...\n|\n\u2514\u2500\u2500\u2500utils\n\u2502   \u2502   ...\n|\n\u2502   ...\n</code></pre> <p>An example content of this file would be:</p> <pre><code># setting for MongoDB\nMONGODB_USERNAME = &lt;YOUR-USERNAME&gt;\nMONGODB_PASSWORD = &lt;YOUR-PASSWORD&gt;\nMONGODB_DATABASE_URL = &lt;YOUR-URL&gt;\n\n# settings for the Dropbox, if you use it as a storage\nAPP_KEY=&lt;YOUR-APP-KEY&gt;\nAPP_SECRET=&lt;YOUR-APP-SECRED&gt;\nREFRESH_TOKEN=&lt;YOUR-REFRESH-TOKEN&gt;\n</code></pre> <p>Then, to configure the storage make sure which one you use as we provide different options. For example, if you use the MongoDB storage you have to set the <code>MONGODB_USERNAME</code>, <code>MONGODB_PASSWORD</code> and <code>MONGODB_DATABASE_URL</code>.</p> <p>If you use the Dropbox storage, add the <code>APP_KEY</code>, <code>APP_SECRET</code> and <code>REFRESH_TOKEN</code> to the <code>.env</code> file.</p> <p>To run the system you should run the <code>maintainer</code> with <code>python maintainer.py</code>.</p> <p>!!! note</p> <pre><code>This step also uploads the configuration of the backends onto the storage. So it is crucial for any kind of tests that involve `qlued`.\n</code></pre> <p>You can now also stop the maintainer and test the system systematically. This can be performed via <code>python - m pytest</code>.</p>"},{"location":"fermions/","title":"Fermionic tweezer","text":"<p>This simulates the hopping of fermions in a fermionic tweezer. It can be used in <code>qiskit-cold-atom</code> as described in this tutorial. Below you can find the API of the simulator.</p>"},{"location":"fermions/#config","title":"Config","text":"<p>In this module we define all the configuration parameters for the fermions package. </p> <p>No simulation is performed here. The entire logic is implemented in the <code>spooler.py</code> module.</p>"},{"location":"fermions/#fermions.config.BarrierInstruction","title":"<code>BarrierInstruction</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The barrier instruction. As each instruction it requires the</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Literal['barrier']</code> <p>The string to identify the instruction</p> <code>wires</code> <code>Annotated[List[Annotated[int, Field(ge=0, le=NUM_WIRES - 1)]], Field(min_length=0, max_length=NUM_WIRES)]</code> <p>The wires on which the instruction should be applied so the indices should be between 0 and NUM_WIRES-1</p> <code>params</code> <code>Annotated[List[float], Field(max_length=0)]</code> <p>has to be empty</p> Source code in <code>fermions/config.py</code> <pre><code>class BarrierInstruction(BaseModel):\n    \"\"\"\n    The barrier instruction. As each instruction it requires the\n\n    Attributes:\n        name: The string to identify the instruction\n        wires: The wires on which the instruction should be applied\n            so the indices should be between 0 and NUM_WIRES-1\n        params: has to be empty\n    \"\"\"\n\n    name: Literal[\"barrier\"]\n    wires: Annotated[\n        List[Annotated[int, Field(ge=0, le=NUM_WIRES - 1)]],\n        Field(min_length=0, max_length=NUM_WIRES),\n    ]\n    params: Annotated[List[float], Field(max_length=0)]\n</code></pre>"},{"location":"fermions/#fermions.config.FermionExperiment","title":"<code>FermionExperiment</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The class that defines the fermion experiments</p> Source code in <code>fermions/config.py</code> <pre><code>class FermionExperiment(BaseModel):\n    \"\"\"\n    The class that defines the fermion experiments\n    \"\"\"\n\n    wire_order: Literal[\"interleaved\"]\n    # we use the Annotated notation to make mypy happy with constrained types\n    shots: Annotated[int, Field(gt=0, le=N_MAX_SHOTS)]\n    num_wires: Annotated[int, Field(ge=1, le=N_MAX_WIRES)]\n    instructions: List[list]\n    seed: Optional[int] = None\n</code></pre>"},{"location":"fermions/#fermions.config.HopInstruction","title":"<code>HopInstruction</code>","text":"<p>             Bases: <code>GateInstruction</code></p> <p>The instruction that applies the hopping gate.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Literal['fhop']</code> <p>How to identify the instruction</p> <code>wires</code> <code>Annotated[List[Annotated[int, Field(ge=0, le=NUM_WIRES - 1)]], Field(min_length=4, max_length=4)]</code> <p>Exactly four wires have to be given.</p> <code>params</code> <code>Annotated[List[Annotated[float, Field(ge=0, le=2 * pi)]], Field(max_length=1)]</code> <p>between 0 and 2 pi</p> <code>coupling_map</code> <code>List</code> <p>contains all the allowed configurations. Currently not used</p> Source code in <code>fermions/config.py</code> <pre><code>class HopInstruction(GateInstruction):\n    \"\"\"\n    The instruction that applies the hopping gate.\n\n    Attributes:\n        name: How to identify the instruction\n        wires: Exactly four wires have to be given.\n        params: between 0 and 2 pi\n        coupling_map: contains all the allowed configurations. Currently not used\n    \"\"\"\n\n    name: Literal[\"fhop\"] = \"fhop\"\n    wires: Annotated[\n        List[Annotated[int, Field(ge=0, le=NUM_WIRES - 1)]],\n        Field(min_length=4, max_length=4),\n    ]\n    params: Annotated[\n        List[Annotated[float, Field(ge=0, le=2 * np.pi)]], Field(max_length=1)\n    ]\n\n    # a string that is sent over to the config dict and that is necessary for compatibility with QISKIT.\n    parameters: str = \"j_i\"\n    description: str = \"hopping of atoms to neighboring tweezers\"\n    # TODO: This should become most likely a type that is then used for the enforcement of the wires.\n    coupling_map: List = [\n        [0, 1, 2, 3],\n        [2, 3, 4, 5],\n        [4, 5, 6, 7],\n        [0, 1, 2, 3, 4, 5, 6, 7],\n    ]\n</code></pre>"},{"location":"fermions/#fermions.config.IntInstruction","title":"<code>IntInstruction</code>","text":"<p>             Bases: <code>GateInstruction</code></p> <p>The instruction that applies the interaction gate.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Literal['fint']</code> <p>How to identify the instruction</p> <code>wires</code> <code>Annotated[List[Annotated[int, Field(ge=0, le=NUM_WIRES - 1)]], Field(min_length=2, max_length=NUM_WIRES)]</code> <p>Exactly one wire has to be given.</p> <code>params</code> <code>Annotated[List[Annotated[float, Field(ge=0, le=2 * pi)]], Field(max_length=1)]</code> <p>Has to be empty</p> Source code in <code>fermions/config.py</code> <pre><code>class IntInstruction(GateInstruction):\n    \"\"\"\n    The instruction that applies the interaction gate.\n\n    Attributes:\n        name: How to identify the instruction\n        wires: Exactly one wire has to be given.\n        params: Has to be empty\n    \"\"\"\n\n    name: Literal[\"fint\"] = \"fint\"\n    wires: Annotated[\n        List[Annotated[int, Field(ge=0, le=NUM_WIRES - 1)]],\n        Field(min_length=2, max_length=NUM_WIRES),\n    ]\n    params: Annotated[\n        List[Annotated[float, Field(ge=0, le=2 * np.pi)]], Field(max_length=1)\n    ]\n\n    # a string that is sent over to the config dict and that is necessary for compatibility with QISKIT.\n    parameters: str = \"u\"\n    description: str = \"on-site interaction of atoms of opposite spin state\"\n    # TODO: This should become most likely a type that is then used for the enforcement of the wires.\n    coupling_map: List = [[0, 1, 2, 3, 4, 5, 6, 7]]\n</code></pre>"},{"location":"fermions/#fermions.config.LoadMeasureInstruction","title":"<code>LoadMeasureInstruction</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The load or measure instruction.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Literal['load', 'measure']</code> <p>How to identify the instruction</p> <code>wires</code> <code>Annotated[List[Annotated[int, Field(ge=0, le=NUM_WIRES - 1)]], Field(min_length=1, max_length=1)]</code> <p>Exactly one wire has to be given.</p> <code>params</code> <code>Annotated[List[float], Field(max_length=0)]</code> <p>Has to be empty</p> Source code in <code>fermions/config.py</code> <pre><code>class LoadMeasureInstruction(BaseModel):\n    \"\"\"\n    The load or measure instruction.\n\n    Attributes:\n        name: How to identify the instruction\n        wires: Exactly one wire has to be given.\n        params: Has to be empty\n    \"\"\"\n\n    name: Literal[\"load\", \"measure\"]\n    wires: Annotated[\n        List[Annotated[int, Field(ge=0, le=NUM_WIRES - 1)]],\n        Field(min_length=1, max_length=1),\n    ]\n    params: Annotated[List[float], Field(max_length=0)]\n</code></pre>"},{"location":"fermions/#fermions.config.PhaseInstruction","title":"<code>PhaseInstruction</code>","text":"<p>             Bases: <code>GateInstruction</code></p> <p>The instruction that applies the interaction gate.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Literal['fphase']</code> <p>How to identify the instruction</p> <code>wires</code> <code>Annotated[List[Annotated[int, Field(ge=0, le=NUM_WIRES - 1)]], Field(min_length=2, max_length=2)]</code> <p>Exactly one wire has to be given.</p> <code>params</code> <code>Annotated[List[Annotated[float, Field(ge=0, le=2 * pi)]], Field(max_length=1)]</code> <p>Has to be empty</p> Source code in <code>fermions/config.py</code> <pre><code>class PhaseInstruction(GateInstruction):\n    \"\"\"\n    The instruction that applies the interaction gate.\n\n    Attributes:\n        name: How to identify the instruction\n        wires: Exactly one wire has to be given.\n        params: Has to be empty\n    \"\"\"\n\n    name: Literal[\"fphase\"] = \"fphase\"\n    wires: Annotated[\n        List[Annotated[int, Field(ge=0, le=NUM_WIRES - 1)]],\n        Field(min_length=2, max_length=2),\n    ]\n    params: Annotated[\n        List[Annotated[float, Field(ge=0, le=2 * np.pi)]], Field(max_length=1)\n    ]\n\n    # a string that is sent over to the config dict and that is necessary for compatibility with QISKIT.\n    parameters: str = \"mu_i\"\n    description: str = (\n        \"Applying a local phase to tweezers through an external potential\"\n    )\n    # TODO: This should become most likely a type that is then used for the enforcement of the wires.\n    coupling_map: List = [[0, 1], [2, 3], [4, 5], [6, 7], [0, 1, 2, 3, 4, 5, 6, 7]]\n</code></pre>"},{"location":"fermions/#simulation-code","title":"Simulation code","text":"<p>The module that contains all the necessary logic for the fermions.</p>"},{"location":"fermions/#fermions.spooler.gen_circuit","title":"<code>gen_circuit(json_dict)</code>","text":"<p>The function the creates the instructions for the circuit.</p> <p>json_dict: The list of instructions for the specific run.</p> Source code in <code>fermions/spooler.py</code> <pre><code>def gen_circuit(json_dict: dict) -&gt; ExperimentDict:\n    \"\"\"The function the creates the instructions for the circuit.\n\n    json_dict: The list of instructions for the specific run.\n    \"\"\"\n    exp_name = next(iter(json_dict))\n    ins_list = json_dict[next(iter(json_dict))][\"instructions\"]\n    n_shots = json_dict[next(iter(json_dict))][\"shots\"]\n    if \"seed\" in json_dict[next(iter(json_dict))]:\n        np.random.seed(json_dict[next(iter(json_dict))][\"seed\"])\n    tweezer_len = 4  # length of the tweezer array\n    n_states = 2 ** (2 * tweezer_len)\n\n    # create all the raising and lowering operators\n    lattice_length = 2 * tweezer_len\n    lowering_op_list = []\n    for i in range(lattice_length):\n        lowering_op_list.append(jordan_wigner_transform(i, lattice_length))\n\n    number_operators = []\n    for i in range(lattice_length):\n        number_operators.append(lowering_op_list[i].T.conj().dot(lowering_op_list[i]))\n    # interaction Hamiltonian\n    h_int = 0 * number_operators[0]\n    for ii in range(tweezer_len):\n        spindown_ind = 2 * ii\n        spinup_ind = 2 * ii + 1\n        h_int += number_operators[spindown_ind].dot(number_operators[spinup_ind])\n\n    # work our way through the instructions\n    psi = 1j * np.zeros(n_states)\n    psi[0] = 1\n    measurement_indices = []\n    shots_array = []\n    # pylint: disable=C0200\n    # Fix this pylint issue whenever you have time, but be careful !\n    for i in range(len(ins_list)):\n        inst = ins_list[i]\n        if inst[0] == \"load\":\n            latt_ind = inst[1][0]\n            psi = np.dot(lowering_op_list[latt_ind].T, psi)\n        if inst[0] == \"fhop\":\n            # the first two indices are the starting points\n            # the other two indices are the end points\n            latt_ind = inst[1]\n            theta = inst[2][0]\n            # couple\n            h_hop = lowering_op_list[latt_ind[0]].T.dot(lowering_op_list[latt_ind[2]])\n            h_hop += lowering_op_list[latt_ind[2]].T.dot(lowering_op_list[latt_ind[0]])\n            h_hop += lowering_op_list[latt_ind[1]].T.dot(lowering_op_list[latt_ind[3]])\n            h_hop += lowering_op_list[latt_ind[3]].T.dot(lowering_op_list[latt_ind[1]])\n            u_hop = expm(-1j * theta * h_hop)\n            psi = np.dot(u_hop, psi)\n        if inst[0] == \"fint\":\n            # the first two indices are the starting points\n            # the other two indices are the end points\n            theta = inst[2][0]\n            u_int = expm(-1j * theta * h_int)\n            # theta = inst[2][0]\n            psi = np.dot(u_int, psi)\n        if inst[0] == \"fphase\":\n            # the first two indices are the starting points\n            # the other two indices are the end points\n            h_phase = 0 * number_operators[0]\n            for ii in inst[1]:  # np.arange(len(inst[1])):\n                h_phase += number_operators[ii]\n            theta = inst[2][0]\n            u_phase = expm(-1j * theta * h_phase)\n            psi = np.dot(u_phase, psi)\n        if inst[0] == \"measure\":\n            measurement_indices.append(inst[1][0])\n\n    # only give back the needed measurments\n    if measurement_indices:\n        probs = np.abs(psi) ** 2\n        result_inds = np.random.choice(np.arange(n_states), p=probs, size=n_shots)\n\n        measurements = np.zeros((n_shots, len(measurement_indices)), dtype=int)\n        for jj in range(n_shots):\n            result = np.zeros(n_states)\n            result[result_inds[jj]] = 1\n\n            for ii, ind in enumerate(measurement_indices):\n                observed = number_operators[ind].dot(result)\n                observed = observed.dot(result)\n                measurements[jj, ii] = int(observed)\n        shots_array = measurements.tolist()\n\n    # print(\"done calc\")\n    exp_sub_dict = create_memory_data(shots_array, exp_name, n_shots)\n    return exp_sub_dict\n</code></pre>"},{"location":"fermions/#fermions.spooler.jordan_wigner_transform","title":"<code>jordan_wigner_transform(j, lattice_length)</code>","text":"<p>Builds up the fermionic operators in a 1D lattice. For details see : https://arxiv.org/abs/0705.1928</p> <p>Parameters:</p> Name Type Description Default <code>j</code> <p>site index</p> required <code>lattice_length</code> <p>how many sites does the lattice have ?</p> required <p>Returns:</p> Name Type Description <code>psi_x</code> <code>ndarray</code> <p>the field operator of creating a fermion on size j</p> Source code in <code>fermions/spooler.py</code> <pre><code>def jordan_wigner_transform(j: int, lattice_length: int) -&gt; np.ndarray:\n    \"\"\"\n    Builds up the fermionic operators in a 1D lattice.\n    For details see : https://arxiv.org/abs/0705.1928\n\n    Args:\n        j : site index\n        lattice_length :  how many sites does the lattice have ?\n\n    Returns:\n        psi_x: the field operator of creating a fermion on size j\n    \"\"\"\n    p_arr = np.array([[0, 1], [0, 0]])\n    z_arr = np.array([[1, 0], [0, -1]])\n    id_arr = np.eye(2)\n    operators = []\n    for dummy in range(j):\n        operators.append(z_arr)\n    operators.append(p_arr)\n    for dummy in range(lattice_length - j - 1):\n        operators.append(id_arr)\n    return nested_kronecker_product(operators)\n</code></pre>"},{"location":"fermions/#fermions.spooler.nested_kronecker_product","title":"<code>nested_kronecker_product(a)</code>","text":"<p>putting together a large operator from a list of matrices.</p> <p>Provide an example here.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>list</code> <p>A list of matrices that can connected.</p> required <p>Returns:</p> Name Type Description <code>array</code> <code>ndarray</code> <p>An matrix that operates on the connected Hilbert space.</p> Source code in <code>fermions/spooler.py</code> <pre><code>def nested_kronecker_product(a: list) -&gt; np.ndarray:\n    \"\"\"putting together a large operator from a list of matrices.\n\n    Provide an example here.\n\n    Args:\n        a (list): A list of matrices that can connected.\n\n    Returns:\n        array: An matrix that operates on the connected Hilbert space.\n    \"\"\"\n    if len(a) == 2:\n        return np.kron(a[0], a[1])\n    else:\n        return np.kron(a[0], nested_kronecker_product(a[1:]))\n</code></pre>"},{"location":"multiqudit/","title":"Multi qudit","text":"<p>This simulates the operation of a number of connected qudits. Below you can find the API of the simulator.</p>"},{"location":"multiqudit/#config","title":"Config","text":"<p>In this module we define all the configuration parameters for the multiqudit package. </p> <p>No simulation is performed here. The entire logic is implemented in the <code>spooler.py</code> module.</p>"},{"location":"multiqudit/#multiqudit.config.BarrierInstruction","title":"<code>BarrierInstruction</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The barrier instruction. As each instruction it requires the</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Literal['barrier']</code> <p>The string to identify the instruction</p> <code>wires</code> <code>Annotated[List[Annotated[int, Field(ge=0, le=N_MAX_WIRES - 1)]], Field(min_length=0, max_length=N_MAX_WIRES)]</code> <p>The wires on which the instruction should be applied so the indices should be between 0 and NUM_WIRES-1</p> <code>params</code> <code>Annotated[List[float], Field(max_length=0)]</code> <p>has to be empty</p> Source code in <code>multiqudit/config.py</code> <pre><code>class BarrierInstruction(BaseModel):\n    \"\"\"\n    The barrier instruction. As each instruction it requires the\n\n    Attributes:\n        name: The string to identify the instruction\n        wires: The wires on which the instruction should be applied\n            so the indices should be between 0 and NUM_WIRES-1\n        params: has to be empty\n    \"\"\"\n\n    name: Literal[\"barrier\"]\n    wires: Annotated[\n        List[Annotated[int, Field(ge=0, le=N_MAX_WIRES - 1)]],\n        Field(min_length=0, max_length=N_MAX_WIRES),\n    ]\n    params: Annotated[List[float], Field(max_length=0)]\n</code></pre>"},{"location":"multiqudit/#multiqudit.config.LoadInstruction","title":"<code>LoadInstruction</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The load instruction.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Literal['load']</code> <p>How to identify the instruction</p> <code>wires</code> <code>Annotated[List[Annotated[int, Field(ge=0, le=N_MAX_WIRES - 1)]], Field(min_length=1, max_length=1)]</code> <p>Exactly one wire has to be given.</p> <code>params</code> <code>Annotated[List[Annotated[int, Field(ge=1, le=N_MAX_ATOMS)]], Field(min_length=1, max_length=1)]</code> <p>The number of atoms to be loaded onto the wire.</p> Source code in <code>multiqudit/config.py</code> <pre><code>class LoadInstruction(BaseModel):\n    \"\"\"\n    The load instruction.\n\n    Attributes:\n        name: How to identify the instruction\n        wires: Exactly one wire has to be given.\n        params: The number of atoms to be loaded onto the wire.\n    \"\"\"\n\n    name: Literal[\"load\"]\n    wires: Annotated[\n        List[Annotated[int, Field(ge=0, le=N_MAX_WIRES - 1)]],\n        Field(min_length=1, max_length=1),\n    ]\n    params: Annotated[\n        List[Annotated[int, Field(ge=1, le=N_MAX_ATOMS)]],\n        Field(min_length=1, max_length=1),\n    ]\n</code></pre>"},{"location":"multiqudit/#multiqudit.config.LocalSqueezingInstruction","title":"<code>LocalSqueezingInstruction</code>","text":"<p>             Bases: <code>GateInstruction</code></p> <p>The rlz2 instruction. As each instruction it requires the</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Literal['rlz2']</code> <p>The string to identify the instruction</p> <code>wires</code> <code>Annotated[List[Annotated[int, Field(ge=0, le=N_MAX_WIRES - 1)]], Field(min_length=1, max_length=1)]</code> <p>The wire on which the instruction should be applied so the indices should be between 0 and N_MAX_WIRES-1</p> <code>params</code> <code>Annotated[List[Annotated[float, Field(ge=0, le=10 * 2 * pi)]], Field(min_length=1, max_length=1)]</code> <p>has to be empty</p> Source code in <code>multiqudit/config.py</code> <pre><code>class LocalSqueezingInstruction(GateInstruction):\n    \"\"\"\n    The rlz2 instruction. As each instruction it requires the\n\n    Attributes:\n        name: The string to identify the instruction\n        wires: The wire on which the instruction should be applied\n            so the indices should be between 0 and N_MAX_WIRES-1\n        params: has to be empty\n    \"\"\"\n\n    name: Literal[\"rlz2\"] = \"rlz2\"\n    wires: Annotated[\n        List[Annotated[int, Field(ge=0, le=N_MAX_WIRES - 1)]],\n        Field(min_length=1, max_length=1),\n    ]\n    params: Annotated[\n        List[Annotated[float, Field(ge=0, le=10 * 2 * pi)]],\n        Field(min_length=1, max_length=1),\n    ]\n\n    # a string that is sent over to the config dict and that is necessary for compatibility with QISKIT.\n    parameters: str = \"chi\"\n    description: str = \"Evolution under lz2\"\n    # TODO: This should become most likely a type that is then used for the enforcement of the wires.\n    coupling_map: List = [[0], [1], [2], [3], [4]]\n    qasm_def: str = \"gate rlz2(chi) {}\"\n</code></pre>"},{"location":"multiqudit/#multiqudit.config.MeasureInstruction","title":"<code>MeasureInstruction</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The measure instruction.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Literal['measure']</code> <p>How to identify the instruction</p> <code>wires</code> <code>Annotated[List[Annotated[int, Field(ge=0, le=N_MAX_WIRES - 1)]], Field(min_length=1, max_length=1)]</code> <p>Exactly one wire has to be given.</p> <code>params</code> <code>Annotated[List[float], Field(max_length=0)]</code> <p>Has to be empty</p> Source code in <code>multiqudit/config.py</code> <pre><code>class MeasureInstruction(BaseModel):\n    \"\"\"\n    The measure instruction.\n\n    Attributes:\n        name: How to identify the instruction\n        wires: Exactly one wire has to be given.\n        params: Has to be empty\n    \"\"\"\n\n    name: Literal[\"measure\"]\n    wires: Annotated[\n        List[Annotated[int, Field(ge=0, le=N_MAX_WIRES - 1)]],\n        Field(min_length=1, max_length=1),\n    ]\n    params: Annotated[List[float], Field(max_length=0)]\n</code></pre>"},{"location":"multiqudit/#multiqudit.config.MultiQuditExperiment","title":"<code>MultiQuditExperiment</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The class that defines the multi qudit experiments</p> Source code in <code>multiqudit/config.py</code> <pre><code>class MultiQuditExperiment(BaseModel):\n    \"\"\"\n    The class that defines the multi qudit experiments\n    \"\"\"\n\n    wire_order: Literal[\"interleaved\", \"sequential\"] = \"sequential\"\n\n    # mypy keeps throwing errors here because it does not understand the type.\n    # not sure how to fix it, so we leave it as is for the moment\n    # HINT: Annotated does not work\n    shots: Annotated[int, Field(gt=0, le=N_MAX_SHOTS)]\n    num_wires: Annotated[int, Field(ge=1, le=N_MAX_WIRES)]\n    instructions: List[list]\n    seed: Optional[int] = None\n</code></pre>"},{"location":"multiqudit/#multiqudit.config.MultiQuditFullInstruction","title":"<code>MultiQuditFullInstruction</code>","text":"<p>             Bases: <code>GateInstruction</code></p> <p>The time evolution under the global Hamiltonian. It does not allow for any local control.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Literal['multiqudit_full']</code> <p>The string to identify the instruction</p> <code>wires</code> <code>Annotated[List[Annotated[int, Field(ge=0, le=N_MAX_WIRES - 1)]], Field(min_length=2, max_length=N_MAX_WIRES)]</code> <p>The wire on which the instruction should be applied so the indices should be between 0 and N_MAX_WIRES-1</p> <code>params</code> <code>Annotated[List[Annotated[float, Field(ge=0, le=5000000.0 * pi)]], Field(min_length=5, max_length=5)]</code> <p>Define the parameter for <code>RX</code>, <code>RZ</code>and <code>RZZ</code> on site, <code>RXY</code>on neighboring sites, <code>RZZ</code> on neighboring sites in this order</p> Source code in <code>multiqudit/config.py</code> <pre><code>class MultiQuditFullInstruction(GateInstruction):\n    \"\"\"\n    The time evolution under the global Hamiltonian. It does not allow for any local control.\n\n    Attributes:\n        name: The string to identify the instruction\n        wires: The wire on which the instruction should be applied\n            so the indices should be between 0 and N_MAX_WIRES-1\n        params: Define the parameter for `RX`, `RZ`and `RZZ` on site, `RXY`on neighboring sites, `RZZ`\n            on neighboring sites in this order\n    \"\"\"\n\n    name: Literal[\"multiqudit_full\"] = \"multiqudit_full\"\n    wires: Annotated[\n        List[Annotated[int, Field(ge=0, le=N_MAX_WIRES - 1)]],\n        Field(min_length=2, max_length=N_MAX_WIRES),\n    ]\n    params: Annotated[\n        List[Annotated[float, Field(ge=0, le=5e6 * pi)]],\n        Field(min_length=5, max_length=5),\n    ]\n\n    # a string that is sent over to the config dict and that is necessary for compatibility with QISKIT.\n    parameters: str = \"omega, delta, chi, Jxy, Jzz\"\n    description: str = \"Apply the Rydberg and Rabi coupling over the whole array.\"\n    # TODO: This should become most likely a type that is then used for the enforcement of the wires.\n    coupling_map: List = [[0], [0, 1], [0, 1, 2], [0, 1, 2, 3], [0, 1, 2, 3, 4]]\n    qasm_def: str = \"gate multiqudit_full(omega, delta, chi, Jxy, Jzz) {}\"\n</code></pre>"},{"location":"multiqudit/#multiqudit.config.MultiQuditSpooler","title":"<code>MultiQuditSpooler</code>","text":"<p>             Bases: <code>Spooler</code></p> <p>The class that contains the logic of the multiqudit spooler.</p> Source code in <code>multiqudit/config.py</code> <pre><code>class MultiQuditSpooler(Spooler):\n    \"\"\"\n    The class that contains the logic of the multiqudit spooler.\n    \"\"\"\n\n    def check_dimension(self, json_dict: dict) -&gt; Tuple[str, bool]:\n        \"\"\"\n        Make sure that the Hilbert space dimension is not too large.\n        \"\"\"\n        dim_ok = False\n        err_code = \"Wrong experiment name or too many experiments\"\n        for expr in json_dict:\n            num_wires = json_dict[expr][\"num_wires\"]\n            dim_hilbert = 1\n            qubit_wires = num_wires\n            ins_list = json_dict[expr][\"instructions\"]\n            for ins in ins_list:\n                if ins[0] == \"load\":\n                    qubit_wires = qubit_wires - 1\n                    dim_hilbert = dim_hilbert * ins[2][0]\n            dim_hilbert = dim_hilbert * (2**qubit_wires)\n            dim_ok = dim_hilbert &lt; (MAX_HILBERT_SPACE_DIM) + 1\n            if not dim_ok:\n                err_code = \"Hilbert space dimension too large!\"\n                break\n        return err_code.replace(\"\\n\", \"..\"), dim_ok\n</code></pre>"},{"location":"multiqudit/#multiqudit.config.MultiQuditSpooler.check_dimension","title":"<code>check_dimension(json_dict)</code>","text":"<p>Make sure that the Hilbert space dimension is not too large.</p> Source code in <code>multiqudit/config.py</code> <pre><code>def check_dimension(self, json_dict: dict) -&gt; Tuple[str, bool]:\n    \"\"\"\n    Make sure that the Hilbert space dimension is not too large.\n    \"\"\"\n    dim_ok = False\n    err_code = \"Wrong experiment name or too many experiments\"\n    for expr in json_dict:\n        num_wires = json_dict[expr][\"num_wires\"]\n        dim_hilbert = 1\n        qubit_wires = num_wires\n        ins_list = json_dict[expr][\"instructions\"]\n        for ins in ins_list:\n            if ins[0] == \"load\":\n                qubit_wires = qubit_wires - 1\n                dim_hilbert = dim_hilbert * ins[2][0]\n        dim_hilbert = dim_hilbert * (2**qubit_wires)\n        dim_ok = dim_hilbert &lt; (MAX_HILBERT_SPACE_DIM) + 1\n        if not dim_ok:\n            err_code = \"Hilbert space dimension too large!\"\n            break\n    return err_code.replace(\"\\n\", \"..\"), dim_ok\n</code></pre>"},{"location":"multiqudit/#multiqudit.config.RlxInstruction","title":"<code>RlxInstruction</code>","text":"<p>             Bases: <code>GateInstruction</code></p> <p>The rlz instruction. As each instruction it requires the</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Literal['rlx']</code> <p>The string to identify the instruction</p> <code>wires</code> <code>Annotated[List[Annotated[int, Field(ge=0, le=N_MAX_WIRES - 1)]], Field(min_length=1, max_length=1)]</code> <p>The wire on which the instruction should be applied so the indices should be between 0 and N_MAX_WIRES-1</p> <code>params</code> <code>Annotated[List[Annotated[float, Field(ge=0, le=2 * pi)]], Field(min_length=1, max_length=1)]</code> <p>has to be empty</p> Source code in <code>multiqudit/config.py</code> <pre><code>class RlxInstruction(GateInstruction):\n    \"\"\"\n    The rlz instruction. As each instruction it requires the\n\n    Attributes:\n        name: The string to identify the instruction\n        wires: The wire on which the instruction should be applied\n            so the indices should be between 0 and N_MAX_WIRES-1\n        params: has to be empty\n    \"\"\"\n\n    name: Literal[\"rlx\"] = \"rlx\"\n    wires: Annotated[\n        List[Annotated[int, Field(ge=0, le=N_MAX_WIRES - 1)]],\n        Field(min_length=1, max_length=1),\n    ]\n    params: Annotated[\n        List[Annotated[float, Field(ge=0, le=2 * pi)]],\n        Field(min_length=1, max_length=1),\n    ]\n\n    # a string that is sent over to the config dict and that is necessary for compatibility with QISKIT.\n    parameters: str = \"omega\"\n    description: str = \"Evolution under Lx\"\n    # TODO: This should become most likely a type that is then used for the enforcement of the wires.\n    coupling_map: List = [[0], [1], [2], [3], [4]]\n    qasm_def: str = \"gate lrx(omega) {}\"\n</code></pre>"},{"location":"multiqudit/#multiqudit.config.RlxlyInstruction","title":"<code>RlxlyInstruction</code>","text":"<p>             Bases: <code>GateInstruction</code></p> <p>The rlxly or rlzlz instruction. As each instruction it requires the</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Literal['rlxly']</code> <p>The string to identify the instruction</p> <code>wires</code> <code>Annotated[List[Annotated[int, Field(ge=0, le=N_MAX_WIRES - 1)]], Field(min_length=2, max_length=N_MAX_WIRES)]</code> <p>The wire on which the instruction should be applied so the indices should be between 0 and N_MAX_WIRES-1</p> <code>params</code> <code>Annotated[List[Annotated[float, Field(ge=0, le=10 * 2 * pi)]], Field(min_length=1, max_length=1)]</code> <p>has to be empty</p> Source code in <code>multiqudit/config.py</code> <pre><code>class RlxlyInstruction(GateInstruction):\n    \"\"\"\n    The rlxly or rlzlz instruction. As each instruction it requires the\n\n    Attributes:\n        name: The string to identify the instruction\n        wires: The wire on which the instruction should be applied\n            so the indices should be between 0 and N_MAX_WIRES-1\n        params: has to be empty\n    \"\"\"\n\n    name: Literal[\"rlxly\"] = \"rlxly\"\n    wires: Annotated[\n        List[Annotated[int, Field(ge=0, le=N_MAX_WIRES - 1)]],\n        Field(min_length=2, max_length=N_MAX_WIRES),\n    ]\n    params: Annotated[\n        List[Annotated[float, Field(ge=0, le=10 * 2 * pi)]],\n        Field(min_length=1, max_length=1),\n    ]\n\n    # a string that is sent over to the config dict and that is necessary for compatibility with QISKIT.\n    parameters: str = \"J\"\n    description: str = \"Entanglement between neighboring gates with an xy interaction\"\n    # TODO: This should become most likely a type that is then used for the enforcement of the wires.\n    coupling_map: List = [[0, 1], [1, 2], [2, 3], [3, 4], [0, 1, 2, 3, 4]]\n    qasm_def: str = \"gate rlylx(J) {}\"\n</code></pre>"},{"location":"multiqudit/#multiqudit.config.RlzInstruction","title":"<code>RlzInstruction</code>","text":"<p>             Bases: <code>GateInstruction</code></p> <p>The rlz instruction. As each instruction it requires the</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Literal['rlz']</code> <p>The string to identify the instruction</p> <code>wires</code> <code>Annotated[List[Annotated[int, Field(ge=0, le=N_MAX_WIRES - 1)]], Field(min_length=1, max_length=1)]</code> <p>The wire on which the instruction should be applied so the indices should be between 0 and N_MAX_WIRES-1</p> <code>params</code> <code>Annotated[List[Annotated[float, Field(ge=0, le=2 * pi)]], Field(min_length=1, max_length=1)]</code> <p>has to be empty</p> Source code in <code>multiqudit/config.py</code> <pre><code>class RlzInstruction(GateInstruction):\n    \"\"\"\n    The rlz instruction. As each instruction it requires the\n\n    Attributes:\n        name: The string to identify the instruction\n        wires: The wire on which the instruction should be applied\n            so the indices should be between 0 and N_MAX_WIRES-1\n        params: has to be empty\n    \"\"\"\n\n    name: Literal[\"rlz\"] = \"rlz\"\n    wires: Annotated[\n        List[Annotated[int, Field(ge=0, le=N_MAX_WIRES - 1)]],\n        Field(min_length=1, max_length=1),\n    ]\n    params: Annotated[\n        List[Annotated[float, Field(ge=0, le=2 * pi)]],\n        Field(min_length=1, max_length=1),\n    ]\n\n    # a string that is sent over to the config dict and that is necessary for compatibility with QISKIT.\n    parameters: str = \"delta\"\n    description: str = \"Evolution under the Z gate\"\n    # TODO: This should become most likely a type that is then used for the enforcement of the wires.\n    coupling_map: List = [[0], [1], [2], [3], [4]]\n    qasm_def: str = \"gate rlz(delta) {}\"\n</code></pre>"},{"location":"multiqudit/#multiqudit.config.RlzlzInstruction","title":"<code>RlzlzInstruction</code>","text":"<p>             Bases: <code>GateInstruction</code></p> <p>The rlzlz instruction. As each instruction it requires the</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Literal['rlzlz']</code> <p>The string to identify the instruction</p> <code>wires</code> <code>Annotated[List[Annotated[int, Field(ge=0, le=N_MAX_WIRES - 1)]], Field(min_length=2, max_length=N_MAX_WIRES)]</code> <p>The wire on which the instruction should be applied so the indices should be between 0 and N_MAX_WIRES-1</p> <code>params</code> <code>Annotated[List[Annotated[float, Field(ge=0, le=10 * 2 * pi)]], Field(min_length=1, max_length=1)]</code> <p>has to be empty</p> Source code in <code>multiqudit/config.py</code> <pre><code>class RlzlzInstruction(GateInstruction):\n    \"\"\"\n    The rlzlz instruction. As each instruction it requires the\n\n    Attributes:\n        name: The string to identify the instruction\n        wires: The wire on which the instruction should be applied\n            so the indices should be between 0 and N_MAX_WIRES-1\n        params: has to be empty\n    \"\"\"\n\n    name: Literal[\"rlzlz\"] = \"rlzlz\"\n    wires: Annotated[\n        List[Annotated[int, Field(ge=0, le=N_MAX_WIRES - 1)]],\n        Field(min_length=2, max_length=N_MAX_WIRES),\n    ]\n    params: Annotated[\n        List[Annotated[float, Field(ge=0, le=10 * 2 * pi)]],\n        Field(min_length=1, max_length=1),\n    ]\n\n    # a string that is sent over to the config dict and that is necessary for compatibility with QISKIT.\n    parameters: str = \"J\"\n    description: str = \"Entanglement between neighboring gates with a zz interaction\"\n    # TODO: This should become most likely a type that is then used for the enforcement of the wires.\n    coupling_map: List = [[0, 1], [1, 2], [2, 3], [3, 4], [0, 1, 2, 3, 4]]\n    qasm_def: str = \"gate rlzlz(J) {}\"\n</code></pre>"},{"location":"multiqudit/#simulation-code","title":"Simulation code","text":"<p>The module that contains all the necessary logic for the multiqudit.</p>"},{"location":"multiqudit/#multiqudit.spooler.gen_circuit","title":"<code>gen_circuit(json_dict)</code>","text":"<p>The function the creates the instructions for the circuit.</p> <p>json_dict: The list of instructions for the specific run.</p> Source code in <code>multiqudit/spooler.py</code> <pre><code>def gen_circuit(json_dict: dict) -&gt; ExperimentDict:\n    \"\"\"The function the creates the instructions for the circuit.\n\n    json_dict: The list of instructions for the specific run.\n    \"\"\"\n    exp_name = next(iter(json_dict))\n    n_shots = json_dict[next(iter(json_dict))][\"shots\"]\n    n_wires = json_dict[next(iter(json_dict))][\"num_wires\"]\n    raw_ins_list = json_dict[next(iter(json_dict))][\"instructions\"]\n    ins_list = [gate_dict_from_list(instr) for instr in raw_ins_list]\n\n    spin_per_wire = 1 / 2 * np.ones(n_wires)\n    if \"seed\" in json_dict[next(iter(json_dict))]:\n        np.random.seed(json_dict[next(iter(json_dict))][\"seed\"])\n\n    for ins in ins_list:\n        if ins.name == \"load\":\n            spin_per_wire[ins.wires[0]] = 1 / 2 * ins.params[0]\n\n    dim_per_wire = 2 * spin_per_wire + np.ones(n_wires)\n    dim_per_wire = dim_per_wire.astype(int)\n    dim_hilbert = np.prod(dim_per_wire)\n\n    # we will need a list of local spin operators as their dimension can change\n    # on each wire\n    lx_list = []\n    ly_list = []\n    lz_list = []\n    lz2_list = []\n\n    for i1 in np.arange(0, n_wires):\n        # let's put together spin matrices\n        spin_length = spin_per_wire[i1]\n        qudit_range = np.arange(spin_length, -(spin_length + 1), -1)\n\n        lx = csc_matrix(\n            1\n            / 2\n            * diags(\n                [\n                    np.sqrt(\n                        [\n                            (spin_length - m + 1) * (spin_length + m)\n                            for m in qudit_range[:-1]\n                        ]\n                    ),\n                    np.sqrt(\n                        [\n                            (spin_length + m + 1) * (spin_length - m)\n                            for m in qudit_range[1:]\n                        ]\n                    ),\n                ],\n                [-1, 1],\n            )\n        )\n        ly = csc_matrix(\n            1\n            / (2 * 1j)\n            * diags(\n                [\n                    np.sqrt(\n                        [\n                            (spin_length - m + 1) * (spin_length + m)\n                            for m in qudit_range[:-1]\n                        ]\n                    ),\n                    -1\n                    * np.sqrt(\n                        [\n                            (spin_length + m + 1) * (spin_length - m)\n                            for m in qudit_range[1:]\n                        ]\n                    ),\n                ],\n                [-1, 1],\n            )\n        )\n        lz = csc_matrix(diags([qudit_range], [0]))\n        lz2 = lz.dot(lz)\n\n        lx_list.append(op_at_wire(lx, i1, list(dim_per_wire)))\n        ly_list.append(op_at_wire(ly, i1, list(dim_per_wire)))\n        lz_list.append(op_at_wire(lz, i1, list(dim_per_wire)))\n        lz2_list.append(op_at_wire(lz2, i1, list(dim_per_wire)))\n\n    initial_state = 1j * np.zeros(dim_per_wire[0])\n    initial_state[0] = 1 + 1j * 0\n    psi = sparse.csc_matrix(initial_state)\n    for i1 in np.arange(1, len(dim_per_wire)):\n        initial_state = 1j * np.zeros(dim_per_wire[i1])\n        initial_state[0] = 1 + 1j * 0\n        psi = sparse.kron(psi, initial_state)\n    psi = psi.T\n\n    measurement_indices = []\n    shots_array = []\n    for inst in ins_list:\n        if inst.name == \"rlx\":\n            position = inst.wires[0]\n            theta = inst.params[0]\n            psi = expm_multiply(-1j * theta * lx_list[position], psi)\n        if inst.name == \"rly\":\n            position = inst.wires[0]\n            theta = inst.params[0]\n            psi = expm_multiply(-1j * theta * ly_list[position], psi)\n        if inst.name == \"rlz\":\n            position = inst.wires[0]\n            theta = inst.params[0]\n            psi = expm_multiply(-1j * theta * lz_list[position], psi)\n        if inst.name == \"rlz2\":\n            position = inst.wires[0]\n            theta = inst.params[0]\n            psi = expm_multiply(-1j * theta * lz2_list[position], psi)\n        if inst.name == \"rlxly\":\n            # apply gate on two qudits\n            if len(inst.wires) == 2:\n                position1 = inst.wires[0]\n                position2 = inst.wires[1]\n                theta = inst.params[0]\n                lp1 = lx_list[position1] + 1j * ly_list[position1]\n                lp2 = lx_list[position2] + 1j * ly_list[position2]\n                lxly = lp1.dot(lp2.conjugate().T)\n                lxly = lxly + lxly.conjugate().T\n                psi = expm_multiply(-1j * theta * lxly, psi)\n            # apply gate on all qudits\n            elif len(inst.wires) == n_wires:\n                theta = inst.params[0]\n                lxly = csc_matrix((dim_hilbert, dim_hilbert))\n                for i1 in np.arange(0, n_wires - 1):\n                    lp1 = lx_list[i1] + 1j * ly_list[i1]\n                    lp2 = lx_list[i1 + 1] + 1j * ly_list[i1 + 1]\n                    lxly = lxly + lp1.dot(lp2.conjugate().T)\n                lxly = lxly + lxly.conjugate().T\n                psi = expm_multiply(-1j * theta * lxly, psi)\n        if inst.name == \"rlzlz\":\n            # apply gate on two quadits\n            if len(inst.wires) == 2:\n                position1 = inst.wires[0]\n                position2 = inst.wires[1]\n                theta = inst.params[0]\n                lzlz = lz_list[position1].dot(lz_list[position2])\n                psi = expm_multiply(-1j * theta * lzlz, psi)\n        if inst.name == \"multiqudit_full\":\n            omega, delta, chi, jxy, jzz = inst.params\n            u_full = csc_matrix((dim_hilbert, dim_hilbert))\n            # first the RX\n            for lxi in lx_list:\n                u_full = u_full + omega * lxi\n            # next the RZ\n            for lzi in lz_list:\n                u_full = u_full + delta * lzi\n            # next the local squeezing\n            for lz2i in lz2_list:\n                u_full = u_full + chi * lz2i\n            # next the neighboring flip-flop\n            for ii in range(n_wires - 1):\n                position1 = ii\n                position2 = ii + 1\n                lp1 = lx_list[position1] + 1j * ly_list[position1]\n                lp2 = lx_list[position2] + 1j * ly_list[position2]\n                lxly = lp1.dot(lp2.conjugate().T)\n                lxly = lxly + lxly.conjugate().T\n                u_full = u_full + jxy * lxly\n            # next the neighboring zz\n            for ii in range(n_wires - 1):\n                lzlz = lz_list[ii].dot(lz_list[ii + 1])\n                u_full = u_full + jzz * lzlz\n            psi = expm_multiply(-1j * u_full, psi)\n        if inst.name == \"measure\":\n            measurement_indices.append(inst.wires[0])\n    if measurement_indices:\n        # the following filters out the results for the indices we prefer.\n        probs = np.squeeze(abs(psi.toarray()) ** 2)\n        result_ind = np.random.choice(dim_hilbert, p=probs, size=n_shots)\n        measurements = np.zeros((n_shots, len(measurement_indices)), dtype=int)\n        for i1 in range(n_shots):\n            observed = np.unravel_index(result_ind[i1], dim_per_wire)\n            # TODO these types are messed up for the moment\n            # as ususal we add an ignore until this gets back to bite us in the ...\n            # but it simply to tough to find out where the typing goes wrong right now.\n            observed = np.array(observed)  # type: ignore\n            measurements[i1, :] = observed[measurement_indices]  # type: ignore\n        shots_array = measurements.tolist()\n\n    exp_sub_dict = create_memory_data(shots_array, exp_name, n_shots, ins_list)\n    return exp_sub_dict\n</code></pre>"},{"location":"multiqudit/#multiqudit.spooler.op_at_wire","title":"<code>op_at_wire(op, pos, dim_per_wire)</code>","text":"<p>Applies an operation onto the wire and provides unitaries on the other wires. Basically this creates the nice tensor products.</p> <p>Parameters:</p> Name Type Description Default <code>op</code> <code>matrix</code> <p>The operation that should be applied.</p> required <code>pos</code> <code>int</code> <p>The wire onto which the operation should be applied.</p> required <code>dim_per_wire</code> <code>int</code> <p>What is the local Hilbert space of each wire.</p> required <p>Returns:</p> Type Description <code>csc_matrix</code> <p>The tensor product matrix.</p> Source code in <code>multiqudit/spooler.py</code> <pre><code>def op_at_wire(op: csc_matrix, pos: int, dim_per_wire: List[int]) -&gt; csc_matrix:\n    \"\"\"\n    Applies an operation onto the wire and provides unitaries on the other wires.\n    Basically this creates the nice tensor products.\n\n    Args:\n        op (matrix): The operation that should be applied.\n        pos (int): The wire onto which the operation should be applied.\n        dim_per_wire (int): What is the local Hilbert space of each wire.\n\n    Returns:\n        The tensor product matrix.\n    \"\"\"\n    # There are two cases the first wire can be the identity or not\n    if pos == 0:\n        res = op\n    else:\n        res = csc_matrix(identity(dim_per_wire[0]))\n    # then loop for the rest\n    for i1 in np.arange(1, len(dim_per_wire)):\n        temp = csc_matrix(identity(dim_per_wire[i1]))\n        if i1 == pos:\n            temp = op\n        res = sparse.kron(res, temp)\n\n    return res\n</code></pre>"},{"location":"rydberg/","title":"Rydberg","text":"<p>This simulates the operation of a Rydberg tweezer array, i.e. a line of qubit that might be entangled through a Rydberg blockade. It can be deployed on qlued as described on their documentation. Below you can find the API of the simulator.</p>"},{"location":"rydberg/#config","title":"Config","text":"<p>In this module we define all the configuration parameters for the Rydberg package. </p> <p>No simulation is performed here. The entire logic is implemented in the <code>spooler.py</code> module.</p>"},{"location":"rydberg/#rydberg.config.BarrierInstruction","title":"<code>BarrierInstruction</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The barrier instruction. As each instruction it requires the</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Literal['barrier']</code> <p>The string to identify the instruction</p> <code>wires</code> <code>Annotated[List[Annotated[int, Field(ge=0, le=N_MAX_WIRES - 1)]], Field(min_length=0, max_length=N_MAX_WIRES)]</code> <p>The wires on which the instruction should be applied so the indices should be between 0 and NUM_WIRES-1</p> <code>params</code> <code>Annotated[List[float], Field(max_length=0)]</code> <p>has to be empty</p> Source code in <code>rydberg/config.py</code> <pre><code>class BarrierInstruction(BaseModel):\n    \"\"\"\n    The barrier instruction. As each instruction it requires the\n\n    Attributes:\n        name: The string to identify the instruction\n        wires: The wires on which the instruction should be applied\n            so the indices should be between 0 and NUM_WIRES-1\n        params: has to be empty\n    \"\"\"\n\n    name: Literal[\"barrier\"]\n    wires: Annotated[\n        List[Annotated[int, Field(ge=0, le=N_MAX_WIRES - 1)]],\n        Field(min_length=0, max_length=N_MAX_WIRES),\n    ]\n    params: Annotated[List[float], Field(max_length=0)]\n</code></pre>"},{"location":"rydberg/#rydberg.config.MeasureInstruction","title":"<code>MeasureInstruction</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The measure instruction.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Literal['measure']</code> <p>How to identify the instruction</p> <code>wires</code> <code>Annotated[List[Annotated[int, Field(ge=0, le=N_MAX_WIRES - 1)]], Field(min_length=1, max_length=1)]</code> <p>Exactly one wire has to be given.</p> <code>params</code> <code>Annotated[List[float], Field(max_length=0)]</code> <p>Has to be empty</p> Source code in <code>rydberg/config.py</code> <pre><code>class MeasureInstruction(BaseModel):\n    \"\"\"\n    The measure instruction.\n\n    Attributes:\n        name: How to identify the instruction\n        wires: Exactly one wire has to be given.\n        params: Has to be empty\n    \"\"\"\n\n    name: Literal[\"measure\"]\n    wires: Annotated[\n        List[Annotated[int, Field(ge=0, le=N_MAX_WIRES - 1)]],\n        Field(min_length=1, max_length=1),\n    ]\n    params: Annotated[List[float], Field(max_length=0)]\n</code></pre>"},{"location":"rydberg/#rydberg.config.RlxInstruction","title":"<code>RlxInstruction</code>","text":"<p>             Bases: <code>GateInstruction</code></p> <p>The rlx instruction. As each instruction it requires the following attributes</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Literal['rlx']</code> <p>The string to identify the instruction</p> <code>wires</code> <code>Annotated[List[Annotated[int, Field(ge=0, le=N_MAX_WIRES - 1)]], Field(min_length=1, max_length=1)]</code> <p>The wire on which the instruction should be applied so the indices should be between 0 and N_MAX_WIRES-1</p> <code>params</code> <code>Annotated[List[Annotated[float, Field(ge=0, le=2 * pi)]], Field(min_length=1, max_length=1)]</code> <p>has to be empty</p> Source code in <code>rydberg/config.py</code> <pre><code>class RlxInstruction(GateInstruction):\n    \"\"\"\n    The rlx instruction. As each instruction it requires the following attributes\n\n    Attributes:\n        name: The string to identify the instruction\n        wires: The wire on which the instruction should be applied\n            so the indices should be between 0 and N_MAX_WIRES-1\n        params: has to be empty\n    \"\"\"\n\n    name: Literal[\"rlx\"] = \"rlx\"\n    wires: Annotated[\n        List[Annotated[int, Field(ge=0, le=N_MAX_WIRES - 1)]],\n        Field(min_length=1, max_length=1),\n    ]\n    params: Annotated[\n        List[Annotated[float, Field(ge=0, le=2 * np.pi)]],\n        Field(min_length=1, max_length=1),\n    ]\n\n    # a string that is sent over to the config dict and that is necessary for compatibility with QISKIT.\n    parameters: str = \"omega\"\n    description: str = \"Evolution under Rlx\"\n    # TODO: This should become most likely a type that is then used for the enforcement of the wires.\n    coupling_map: List = [[0], [1], [2], [3], [4]]\n    qasm_def: str = \"gate rlx(omega) {}\"\n</code></pre>"},{"location":"rydberg/#rydberg.config.RlzInstruction","title":"<code>RlzInstruction</code>","text":"<p>             Bases: <code>GateInstruction</code></p> <p>The rlz instruction. As each instruction it requires the</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Literal['rlz']</code> <p>The string to identify the instruction</p> <code>wires</code> <code>Annotated[List[Annotated[int, Field(ge=0, le=N_MAX_WIRES - 1)]], Field(min_length=1, max_length=1)]</code> <p>The wire on which the instruction should be applied so the indices should be between 0 and N_MAX_WIRES-1</p> <code>params</code> <code>Annotated[List[Annotated[float, Field(ge=0, le=2 * pi)]], Field(min_length=1, max_length=1)]</code> <p>has to be empty</p> Source code in <code>rydberg/config.py</code> <pre><code>class RlzInstruction(GateInstruction):\n    \"\"\"\n    The rlz instruction. As each instruction it requires the\n\n    Attributes:\n        name: The string to identify the instruction\n        wires: The wire on which the instruction should be applied\n            so the indices should be between 0 and N_MAX_WIRES-1\n        params: has to be empty\n    \"\"\"\n\n    name: Literal[\"rlz\"] = \"rlz\"\n    wires: Annotated[\n        List[Annotated[int, Field(ge=0, le=N_MAX_WIRES - 1)]],\n        Field(min_length=1, max_length=1),\n    ]\n    params: Annotated[\n        List[Annotated[float, Field(ge=0, le=2 * np.pi)]],\n        Field(min_length=1, max_length=1),\n    ]\n\n    # a string that is sent over to the config dict and that is necessary for compatibility with QISKIT.\n    parameters: str = \"delta\"\n    description: str = \"Evolution under the Rlz gate\"\n    # TODO: This should become most likely a type that is then used for the enforcement of the wires.\n    coupling_map: List = [[0], [1], [2], [3], [4]]\n    qasm_def: str = \"gate rlz(delta) {}\"\n</code></pre>"},{"location":"rydberg/#rydberg.config.RydbergBlockInstruction","title":"<code>RydbergBlockInstruction</code>","text":"<p>             Bases: <code>GateInstruction</code></p> <p>The Rydberg blockade instruction. As each instruction it requires the</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Literal['rydberg_block']</code> <p>The string to identify the instruction</p> <code>wires</code> <code>Annotated[List[Annotated[int, Field(ge=0, le=N_MAX_WIRES - 1)]], Field(min_length=2, max_length=N_MAX_WIRES)]</code> <p>The wire on which the instruction should be applied so the indices should be between 0 and N_MAX_WIRES-1</p> <code>params</code> <code>Annotated[List[Annotated[float, Field(ge=0, le=2 * pi)]], Field(min_length=1, max_length=1)]</code> <p>has to be empty</p> Source code in <code>rydberg/config.py</code> <pre><code>class RydbergBlockInstruction(GateInstruction):\n    \"\"\"\n    The Rydberg blockade instruction. As each instruction it requires the\n\n    Attributes:\n        name: The string to identify the instruction\n        wires: The wire on which the instruction should be applied\n            so the indices should be between 0 and N_MAX_WIRES-1\n        params: has to be empty\n    \"\"\"\n\n    name: Literal[\"rydberg_block\"] = \"rydberg_block\"\n    wires: Annotated[\n        List[Annotated[int, Field(ge=0, le=N_MAX_WIRES - 1)]],\n        Field(min_length=2, max_length=N_MAX_WIRES),\n    ]\n    params: Annotated[\n        List[Annotated[float, Field(ge=0, le=2 * np.pi)]],\n        Field(min_length=1, max_length=1),\n    ]\n\n    # a string that is sent over to the config dict and that is necessary for compatibility with QISKIT.\n    parameters: str = \"phi\"\n    description: str = \"Apply the Rydberg blockade over the whole array\"\n    # TODO: This should become most likely a type that is then used for the enforcement of the wires.\n    coupling_map: List = [[0, 1, 2, 3, 4]]\n    qasm_def: str = \"gate rydberg_block(phi) {}\"\n</code></pre>"},{"location":"rydberg/#rydberg.config.RydbergExperiment","title":"<code>RydbergExperiment</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The class that defines the Rydberg experiments. Each of those <code>RydbergExperiment</code>s is executed on a <code>RydbergSpooler</code>.</p> Source code in <code>rydberg/config.py</code> <pre><code>class RydbergExperiment(BaseModel):\n    \"\"\"\n    The class that defines the Rydberg experiments. Each of those\n    `RydbergExperiment`s is executed on a `RydbergSpooler`.\n    \"\"\"\n\n    wire_order: Literal[\"interleaved\", \"sequential\"] = \"sequential\"\n    # mypy keeps throwing errors here because it does not understand the type.\n    # not sure how to fix it, so we leave it as is for the moment\n    # HINT: Annotated does not work\n    shots: Annotated[int, Field(gt=0, le=N_MAX_SHOTS)]\n    num_wires: Annotated[int, Field(ge=1, le=N_MAX_WIRES)]\n    instructions: List[list]\n    seed: Optional[int] = None\n</code></pre>"},{"location":"rydberg/#rydberg.config.RydbergFullInstruction","title":"<code>RydbergFullInstruction</code>","text":"<p>             Bases: <code>GateInstruction</code></p> <p>The time evolution under the global Hamiltonian. It does not allow for any local control.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Literal['rydberg_full']</code> <p>The string to identify the instruction</p> <code>wires</code> <code>Annotated[List[Annotated[int, Field(ge=0, le=N_MAX_WIRES - 1)]], Field(min_length=2, max_length=N_MAX_WIRES)]</code> <p>The wire on which the instruction should be applied so the indices should be between 0 and N_MAX_WIRES-1</p> <code>params</code> <code>Annotated[List[Annotated[float, Field(ge=0, le=5000000.0 * pi)]], Field(min_length=3, max_length=3)]</code> <p>Define the parameter for <code>RX</code>, <code>RZ</code>and <code>RydbergBlock</code> in this order</p> Source code in <code>rydberg/config.py</code> <pre><code>class RydbergFullInstruction(GateInstruction):\n    \"\"\"\n    The time evolution under the global Hamiltonian. It does not allow for any local control.\n\n    Attributes:\n        name: The string to identify the instruction\n        wires: The wire on which the instruction should be applied\n            so the indices should be between 0 and N_MAX_WIRES-1\n        params: Define the parameter for `RX`, `RZ`and `RydbergBlock` in this order\n    \"\"\"\n\n    name: Literal[\"rydberg_full\"] = \"rydberg_full\"\n    wires: Annotated[\n        List[Annotated[int, Field(ge=0, le=N_MAX_WIRES - 1)]],\n        Field(min_length=2, max_length=N_MAX_WIRES),\n    ]\n    params: Annotated[\n        List[Annotated[float, Field(ge=0, le=5e6 * np.pi)]],\n        Field(min_length=3, max_length=3),\n    ]\n\n    # a string that is sent over to the config dict and that is necessary for compatibility with QISKIT.\n    parameters: str = \"omega, delta, phi\"\n    description: str = \"Apply the Rydberg and Rabi coupling over the whole array.\"\n    # TODO: This should become most likely a type that is then used for the enforcement of the wires.\n    coupling_map: List = [[0, 1, 2, 3, 4]]\n    qasm_def: str = \"gate rydberg_full(omega, delta, phi) {}\"\n</code></pre>"},{"location":"rydberg/#simulation-code","title":"Simulation code","text":"<p>The module that contains all the necessary logic for the Rydberg simulator. It has to implement the code that is executed for all the instructions that we defined  in the  <code>config.py</code> file.</p>"},{"location":"rydberg/#rydberg.spooler.gen_circuit","title":"<code>gen_circuit(json_dict)</code>","text":"<p>The function the creates the instructions for the circuit.</p> <p>json_dict: The list of instructions for the specific run.</p> Source code in <code>rydberg/spooler.py</code> <pre><code>def gen_circuit(json_dict: dict) -&gt; ExperimentDict:\n    \"\"\"The function the creates the instructions for the circuit.\n\n    json_dict: The list of instructions for the specific run.\n    \"\"\"\n    exp_name = next(iter(json_dict))\n    raw_ins_list = json_dict[next(iter(json_dict))][\"instructions\"]\n    ins_list = [gate_dict_from_list(instr) for instr in raw_ins_list]\n\n    n_shots = json_dict[next(iter(json_dict))][\"shots\"]\n    n_wires = json_dict[next(iter(json_dict))][\"num_wires\"]\n    spin_per_wire = 1 / 2 * np.ones(n_wires)\n    if \"seed\" in json_dict[next(iter(json_dict))]:\n        np.random.seed(json_dict[next(iter(json_dict))][\"seed\"])\n\n    dim_per_wire = 2 * spin_per_wire + np.ones(n_wires)\n    dim_per_wire = dim_per_wire.astype(int)\n    dim_hilbert = np.prod(dim_per_wire)\n\n    # we will need a list of local spin operators as their dimension can change\n    # on each wire\n    lx_list = []\n    ly_list = []\n    lz_list = []\n    nocc_list = []\n    spin_length = 1 / 2\n    qudit_range = np.arange(spin_length, -(spin_length + 1), -1)\n    lx = csc_matrix(\n        1\n        / 2\n        * diags(\n            [\n                np.sqrt(\n                    [\n                        (spin_length - m + 1) * (spin_length + m)\n                        for m in qudit_range[:-1]\n                    ]\n                ),\n                np.sqrt(\n                    [(spin_length + m + 1) * (spin_length - m) for m in qudit_range[1:]]\n                ),\n            ],\n            [-1, 1],\n        )\n    )\n    ly = csc_matrix(\n        1\n        / (2 * 1j)\n        * diags(\n            [\n                np.sqrt(\n                    [\n                        (spin_length - m + 1) * (spin_length + m)\n                        for m in qudit_range[:-1]\n                    ]\n                ),\n                -1\n                * np.sqrt(\n                    [(spin_length + m + 1) * (spin_length - m) for m in qudit_range[1:]]\n                ),\n            ],\n            [-1, 1],\n        )\n    )\n\n    lz = csc_matrix(diags([qudit_range], [0]))\n    # nocc = csc_matrix(diags([qudit_range + 1 / 2], [0]))\n    nocc = csc_matrix(diags([-qudit_range + 1 / 2], [0]))\n\n    for i1 in np.arange(0, n_wires):\n        # let's put together spin matrices\n        lx_list.append(op_at_wire(lx, i1, list(dim_per_wire)))\n        ly_list.append(op_at_wire(ly, i1, list(dim_per_wire)))\n        lz_list.append(op_at_wire(lz, i1, list(dim_per_wire)))\n        nocc_list.append(op_at_wire(nocc, i1, list(dim_per_wire)))\n\n    int_matrix = csc_matrix((dim_hilbert, dim_hilbert))\n    for i1 in np.arange(0, n_wires):\n        for i2 in np.arange(i1 + 1, n_wires):\n            int_matrix = (\n                int_matrix + nocc_list[i1].dot(nocc_list[i2]) / np.abs(i1 - i2) ** 6\n            )\n\n    initial_state = 1j * np.zeros(dim_per_wire[0])\n    initial_state[0] = 1 + 1j * 0\n    psi = sparse.csc_matrix(initial_state)\n    for i1 in np.arange(1, len(dim_per_wire)):\n        initial_state = 1j * np.zeros(dim_per_wire[i1])\n        initial_state[0] = 1 + 1j * 0\n        psi = sparse.kron(psi, initial_state)\n    psi = psi.T\n\n    measurement_indices = []\n    shots_array = []\n    for inst in ins_list:\n        if inst.name == \"rlx\":\n            position = inst.wires[0]\n            theta = inst.params[0]\n            psi = expm_multiply(-1j * theta * lx_list[position], psi)\n        if inst.name == \"rlz\":\n            position = inst.wires[0]\n            theta = inst.params[0]\n            psi = expm_multiply(-1j * theta * lz_list[position], psi)\n        if inst.name == \"rydberg_block\":\n            # apply gate on all qubits\n            theta = inst.params[0]\n            psi = expm_multiply(-1j * theta * int_matrix, psi)\n        if inst.name == \"rydberg_full\":\n            omega, delta, phi = inst.params\n            u_full = csc_matrix((dim_hilbert, dim_hilbert))\n            # first the RX\n            for lxi in lx_list:\n                u_full = u_full + omega * lxi\n            # next the RZ\n            for lzi in lz_list:\n                u_full = u_full + delta * lzi\n            # end the blockade\n            u_full = u_full + phi * int_matrix\n            psi = expm_multiply(-1j * u_full, psi)\n        if inst.name == \"measure\":\n            measurement_indices.append(inst.wires[0])\n    if measurement_indices:\n        # the following filters out the results for the indices we prefer.\n        probs = np.squeeze(abs(psi.toarray()) ** 2)\n        result_ind = np.random.choice(dim_hilbert, p=probs, size=n_shots)\n        measurements = np.zeros((n_shots, len(measurement_indices)), dtype=int)\n        for i1 in range(n_shots):\n            observed = np.unravel_index(result_ind[i1], dim_per_wire)\n            # TODO these types are messed up for the moment\n            # as ususal we add an ignore until this gets back to bite us in the ...\n            # but it simply to tough to find out where the typing goes wrong right now.\n            observed = np.array(observed)  # type: ignore\n            measurements[i1, :] = observed[measurement_indices]  # type: ignore\n        shots_array = measurements.tolist()\n\n    exp_sub_dict = create_memory_data(shots_array, exp_name, n_shots, ins_list)\n    return exp_sub_dict\n</code></pre>"},{"location":"rydberg/#rydberg.spooler.op_at_wire","title":"<code>op_at_wire(op, pos, dim_per_wire)</code>","text":"<p>Applies an operation onto the wire and provides unitaries on the other wires. Basically this creates the nice tensor products.</p> <p>Parameters:</p> Name Type Description Default <code>op</code> <code>matrix</code> <p>The operation that should be applied.</p> required <code>pos</code> <code>int</code> <p>The wire onto which the operation should be applied.</p> required <code>dim_per_wire</code> <code>int</code> <p>What is the local Hilbert space of each wire.</p> required <p>Returns:</p> Type Description <code>csc_matrix</code> <p>The tensor product matrix.</p> Source code in <code>rydberg/spooler.py</code> <pre><code>def op_at_wire(op: csc_matrix, pos: int, dim_per_wire: List[int]) -&gt; csc_matrix:\n    \"\"\"\n    Applies an operation onto the wire and provides unitaries on the other wires.\n    Basically this creates the nice tensor products.\n\n    Args:\n        op (matrix): The operation that should be applied.\n        pos (int): The wire onto which the operation should be applied.\n        dim_per_wire (int): What is the local Hilbert space of each wire.\n\n    Returns:\n        The tensor product matrix.\n    \"\"\"\n    # There are two cases the first wire can be the identity or not\n    if pos == 0:\n        res = op\n    else:\n        res = csc_matrix(identity(dim_per_wire[0]))\n    # then loop for the rest\n    for i1 in np.arange(1, len(dim_per_wire)):\n        temp = csc_matrix(identity(dim_per_wire[i1]))\n        if i1 == pos:\n            temp = op\n        res = sparse.kron(res, temp)\n\n    return res\n</code></pre>"},{"location":"singlequdit/","title":"Single qudit","text":"<p>This simulates the operation of a single qudit, i.e. collective spin or angular momentum operator. It can be used in <code>qiskit-cold-atom</code> as described in this tutorial. Below you can find the API of the simulator.</p>"},{"location":"singlequdit/#config","title":"Config","text":"<p>In this module we define all the configuration parameters for the singlequdit package. </p> <p>No simulation is performed here. The entire logic is implemented in the <code>spooler.py</code> module.</p>"},{"location":"singlequdit/#singlequdit.config.LoadInstruction","title":"<code>LoadInstruction</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The load instruction. As each instruction it requires the</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Literal['load']</code> <p>The string to identify the instruction</p> <code>wires</code> <code>Annotated[List[Annotated[int, Field(ge=0, le=0)]], Field(min_length=0, max_length=1)]</code> <p>The wire on which the instruction should be applied so the indices should be between 0 and N_MAX_WIRES-1</p> <code>params</code> <code>Annotated[List[Annotated[int, Field(ge=1, le=N_MAX_ATOMS)]], Field(min_length=1, max_length=1)]</code> <p>has to be empty</p> Source code in <code>singlequdit/config.py</code> <pre><code>class LoadInstruction(BaseModel):\n    \"\"\"\n    The load instruction. As each instruction it requires the\n\n    Attributes:\n        name: The string to identify the instruction\n        wires: The wire on which the instruction should be applied\n            so the indices should be between 0 and N_MAX_WIRES-1\n        params: has to be empty\n    \"\"\"\n\n    name: Literal[\"load\"]\n    wires: Annotated[\n        List[Annotated[int, Field(ge=0, le=0)]], Field(min_length=0, max_length=1)\n    ]\n    params: Annotated[\n        List[Annotated[int, Field(ge=1, le=N_MAX_ATOMS)]],\n        Field(min_length=1, max_length=1),\n    ]\n</code></pre>"},{"location":"singlequdit/#singlequdit.config.LocalSqueezingInstruction","title":"<code>LocalSqueezingInstruction</code>","text":"<p>             Bases: <code>GateInstruction</code></p> <p>The rlz2 instruction. As each instruction it requires the</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Literal['rlz2']</code> <p>The string to identify the instruction</p> <code>wires</code> <code>Annotated[List[Annotated[int, Field(ge=0, le=0)]], Field(min_length=0, max_length=1)]</code> <p>The wire on which the instruction should be applied so the indices should be between 0 and N_MAX_WIRES-1</p> <code>params</code> <code>Annotated[List[Annotated[float, Field(ge=0, le=10 * 2 * pi)]], Field(min_length=1, max_length=1)]</code> <p>has to be empty</p> Source code in <code>singlequdit/config.py</code> <pre><code>class LocalSqueezingInstruction(GateInstruction):\n    \"\"\"\n    The rlz2 instruction. As each instruction it requires the\n\n    Attributes:\n        name: The string to identify the instruction\n        wires: The wire on which the instruction should be applied\n            so the indices should be between 0 and N_MAX_WIRES-1\n        params: has to be empty\n    \"\"\"\n\n    name: Literal[\"rlz2\"] = \"rlz2\"\n    wires: Annotated[\n        List[Annotated[int, Field(ge=0, le=0)]], Field(min_length=0, max_length=1)\n    ]\n    params: Annotated[\n        List[Annotated[float, Field(ge=0, le=10 * 2 * np.pi)]],\n        Field(min_length=1, max_length=1),\n    ]\n\n    # a string that is sent over to the config dict and that is necessary for compatibility with QISKIT.\n    parameters: str = \"chi\"\n    description: str = \"Evolution under lz2\"\n    # TODO: This should become most likely a type that is then used for the enforcement of the wires.\n    coupling_map: List = [[0]]\n    qasm_def: str = \"gate rlz2(chi) {}\"\n</code></pre>"},{"location":"singlequdit/#singlequdit.config.MeasureBarrierInstruction","title":"<code>MeasureBarrierInstruction</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The measure and barrier instruction. As each instruction it requires the</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Literal['measure', 'barrier']</code> <p>The string to identify the instruction</p> <code>wires</code> <code>Annotated[List[Annotated[int, Field(ge=0, le=0)]], Field(min_length=0, max_length=1)]</code> <p>The wire on which the instruction should be applied so the index should be 0</p> <code>params</code> <code>Annotated[List[float], Field(min_length=0, max_length=0)]</code> <p>has to be empty</p> Source code in <code>singlequdit/config.py</code> <pre><code>class MeasureBarrierInstruction(BaseModel):\n    \"\"\"\n    The measure and barrier instruction. As each instruction it requires the\n\n    Attributes:\n        name: The string to identify the instruction\n        wires: The wire on which the instruction should be applied\n            so the index should be 0\n        params: has to be empty\n    \"\"\"\n\n    name: Literal[\"measure\", \"barrier\"]\n    wires: Annotated[\n        List[Annotated[int, Field(ge=0, le=0)]], Field(min_length=0, max_length=1)\n    ]\n    params: Annotated[List[float], Field(min_length=0, max_length=0)]\n</code></pre>"},{"location":"singlequdit/#singlequdit.config.RlxInstruction","title":"<code>RlxInstruction</code>","text":"<p>             Bases: <code>GateInstruction</code></p> <p>The rlx instruction. As each instruction it requires the</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Literal['rlx']</code> <p>The string to identify the instruction</p> <code>wires</code> <code>Annotated[List[Annotated[int, Field(ge=0, le=0)]], Field(min_length=0, max_length=1)]</code> <p>The wire on which the instruction should be applied so the indices should be between 0 and N_MAX_WIRES-1</p> <code>params</code> <code>Annotated[List[Annotated[float, Field(ge=0, le=2 * pi)]], Field(min_length=1, max_length=1)]</code> <p>has to be empty</p> Source code in <code>singlequdit/config.py</code> <pre><code>class RlxInstruction(GateInstruction):\n    \"\"\"\n    The rlx instruction. As each instruction it requires the\n\n    Attributes:\n        name: The string to identify the instruction\n        wires: The wire on which the instruction should be applied\n            so the indices should be between 0 and N_MAX_WIRES-1\n        params: has to be empty\n    \"\"\"\n\n    name: Literal[\"rlx\"] = \"rlx\"\n    wires: Annotated[\n        List[Annotated[int, Field(ge=0, le=0)]], Field(min_length=0, max_length=1)\n    ]\n    params: Annotated[\n        List[Annotated[float, Field(ge=0, le=2 * np.pi)]],\n        Field(min_length=1, max_length=1),\n    ]\n\n    # a string that is sent over to the config dict and that is necessary for compatibility with QISKIT.\n    parameters: str = \"omega\"\n    description: str = \"Evolution under Lx\"\n    # TODO: This should become most likely a type that is then used for the enforcement of the wires.\n    coupling_map: List = [[0]]\n    qasm_def: str = \"gate lrx(omega) {}\"\n</code></pre>"},{"location":"singlequdit/#singlequdit.config.RlzInstruction","title":"<code>RlzInstruction</code>","text":"<p>             Bases: <code>GateInstruction</code></p> <p>The rlz instruction. As each instruction it requires the</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Literal['rlz']</code> <p>The string to identify the instruction</p> <code>wires</code> <code>Annotated[List[Annotated[int, Field(ge=0, le=0)]], Field(min_length=0, max_length=1)]</code> <p>The wire on which the instruction should be applied so the indices should be between 0 and N_MAX_WIRES-1</p> <code>params</code> <code>Annotated[List[Annotated[float, Field(ge=0, le=2 * pi)]], Field(min_length=1, max_length=1)]</code> <p>has to be empty</p> Source code in <code>singlequdit/config.py</code> <pre><code>class RlzInstruction(GateInstruction):\n    \"\"\"\n    The rlz instruction. As each instruction it requires the\n\n    Attributes:\n        name: The string to identify the instruction\n        wires: The wire on which the instruction should be applied\n            so the indices should be between 0 and N_MAX_WIRES-1\n        params: has to be empty\n    \"\"\"\n\n    name: Literal[\"rlz\"] = \"rlz\"\n    wires: Annotated[\n        List[Annotated[int, Field(ge=0, le=0)]], Field(min_length=0, max_length=1)\n    ]\n    params: Annotated[\n        List[Annotated[float, Field(ge=0, le=2 * np.pi)]],\n        Field(min_length=1, max_length=1),\n    ]\n\n    # a string that is sent over to the config dict and that is necessary for compatibility with QISKIT.\n    parameters: str = \"delta\"\n    description: str = \"Evolution under the Z gate\"\n    # TODO: This should become most likely a type that is then used for the enforcement of the wires.\n    coupling_map: List = [[0]]\n    qasm_def: str = \"gate rlz(delta) {}\"\n</code></pre>"},{"location":"singlequdit/#singlequdit.config.SingleQuditExperiment","title":"<code>SingleQuditExperiment</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The class that defines the single qudit experiments</p> Source code in <code>singlequdit/config.py</code> <pre><code>class SingleQuditExperiment(BaseModel):\n    \"\"\"\n    The class that defines the single qudit experiments\n    \"\"\"\n\n    wire_order: Literal[\"interleaved\", \"sequential\"] = \"sequential\"\n    # mypy keeps throwing errors here because it does not understand the type.\n    # not sure how to fix it, so we leave it as is for the moment\n    # HINT: Annotated does not work\n    shots: Annotated[int, Field(gt=0, le=N_MAX_SHOTS)]\n    num_wires: Literal[1]\n    instructions: List[list]\n    seed: Optional[int] = None\n</code></pre>"},{"location":"singlequdit/#singlequdit.config.SinglequditFullInstruction","title":"<code>SinglequditFullInstruction</code>","text":"<p>             Bases: <code>GateInstruction</code></p> <p>The evolution under the full Hamiltonian. As each instruction it requires the</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Literal['sq_full']</code> <p>The string to identify the instruction</p> <code>wires</code> <code>Annotated[List[Annotated[int, Field(ge=0, le=0)]], Field(min_length=0, max_length=1)]</code> <p>The wire on which the instruction should be applied so the indices should be between 0 and N_MAX_WIRES-1</p> <code>params</code> <code>Annotated[List[Annotated[float, Field(ge=0, le=5000000.0 * pi)]], Field(min_length=3, max_length=3)]</code> <p>Define the parameter for <code>RX</code>, <code>RZ</code>and <code>RZ2</code> in this order</p> Source code in <code>singlequdit/config.py</code> <pre><code>class SinglequditFullInstruction(GateInstruction):\n    \"\"\"\n    The evolution under the full Hamiltonian. As each instruction it requires the\n\n    Attributes:\n        name: The string to identify the instruction\n        wires: The wire on which the instruction should be applied\n            so the indices should be between 0 and N_MAX_WIRES-1\n        params: Define the parameter for `RX`, `RZ`and `RZ2` in this order\n    \"\"\"\n\n    name: Literal[\"sq_full\"] = \"sq_full\"\n    wires: Annotated[\n        List[Annotated[int, Field(ge=0, le=0)]], Field(min_length=0, max_length=1)\n    ]\n    params: Annotated[\n        List[Annotated[float, Field(ge=0, le=5e6 * np.pi)]],\n        Field(min_length=3, max_length=3),\n    ]\n\n    # a string that is sent over to the config dict and that is necessary for compatibility with QISKIT.\n    parameters: str = \"omega, delta, chi\"\n    description: str = \"Apply the full time evolution on the array.\"\n    # TODO: This should become most likely a type that is then used for the enforcement of the wires.\n    coupling_map: List = [[0]]\n    qasm_def: str = \"gate sq_full(omega, delta, chi) {}\"\n</code></pre>"},{"location":"singlequdit/#simulation-code","title":"Simulation code","text":"<p>The module that contains all the necessary logic to simulate the singlequdit.  It has to implement the code that is executed for all the instructions that we defined  in the <code>conf.py</code> file.</p>"},{"location":"singlequdit/#singlequdit.spooler.gen_circuit","title":"<code>gen_circuit(json_dict)</code>","text":"<p>The function the creates the instructions for the circuit. json_dict: The list of instructions for the specific run.</p> Source code in <code>singlequdit/spooler.py</code> <pre><code>def gen_circuit(json_dict: dict) -&gt; ExperimentDict:\n    \"\"\"The function the creates the instructions for the circuit.\n    json_dict: The list of instructions for the specific run.\n    \"\"\"\n    # pylint: disable=R0914\n    exp_name = next(iter(json_dict))\n    ins_list = json_dict[next(iter(json_dict))][\"instructions\"]\n    n_shots = json_dict[next(iter(json_dict))][\"shots\"]\n    raw_ins_list = json_dict[next(iter(json_dict))][\"instructions\"]\n    ins_list = [gate_dict_from_list(instr) for instr in raw_ins_list]\n\n    if \"seed\" in json_dict[next(iter(json_dict))]:\n        np.random.seed(json_dict[next(iter(json_dict))][\"seed\"])\n\n    n_atoms = 1\n    spin_len = n_atoms / 2  # spin length\n\n    # let's put together spin matrices\n    dim_qudit = n_atoms + 1\n    qudit_range = np.arange(spin_len, -(spin_len + 1), -1)\n\n    lx = csc_matrix(\n        1\n        / 2\n        * diags(\n            [\n                np.sqrt(\n                    [(spin_len - m + 1) * (spin_len + m) for m in qudit_range[:-1]]\n                ),\n                np.sqrt([(spin_len + m + 1) * (spin_len - m) for m in qudit_range[1:]]),\n            ],\n            [-1, 1],\n        )\n    )\n    lz = csc_matrix(diags([qudit_range], [0]))\n    lz2 = lz.multiply(lz)\n\n    psi = 1j * np.zeros(dim_qudit)\n    psi[0] = 1 + 1j * 0\n    shots_array = []\n    # work our way through the instructions\n    for inst in ins_list:\n        # this must always be the first instruction. Otherwise we should\n        # raise some error\n        if inst.name == \"load\":\n            n_atoms = int(inst.params[0])\n            spin_len = n_atoms / 2\n            # length of the qudit\n            dim_qudit = n_atoms + 1\n            qudit_range = np.arange(spin_len, -(spin_len + 1), -1)\n\n            lx = csc_matrix(\n                1\n                / 2\n                * diags(\n                    [\n                        np.sqrt(\n                            [\n                                (spin_len - m + 1) * (spin_len + m)\n                                for m in qudit_range[:-1]\n                            ]\n                        ),\n                        np.sqrt(\n                            [\n                                (spin_len + m + 1) * (spin_len - m)\n                                for m in qudit_range[1:]\n                            ]\n                        ),\n                    ],\n                    [-1, 1],\n                )\n            )\n            lz = csc_matrix(diags([qudit_range], [0]))\n\n            lz2 = lz.multiply(lz)\n\n            psi = 1j * np.zeros(dim_qudit)\n            psi[0] = 1 + 1j * 0\n\n        if inst.name == \"rlx\":\n            theta = inst.params[0]\n            psi = expm_multiply(-1j * theta * lx, psi)\n        if inst.name == \"rlz\":\n            theta = inst.params[0]\n            psi = expm_multiply(-1j * theta * lz, psi)\n        if inst.name == \"rlz2\":\n            theta = inst.params[0]\n            psi = expm_multiply(-1j * theta * lz2, psi)\n        if inst.name == \"sq_full\":\n            omega, delta, chi = inst.params\n            h_full = omega * lx + delta * lz + chi * lz2\n            psi = expm_multiply(-1j * h_full, psi)\n        if inst.name == \"measure\":\n            probs = np.abs(psi) ** 2\n            result = np.random.choice(np.arange(dim_qudit), p=probs, size=n_shots)\n    shots_array = result.tolist()\n    exp_sub_dict = create_memory_data(shots_array, exp_name, n_shots, ins_list)\n    return exp_sub_dict\n</code></pre>"}]}